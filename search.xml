<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[spring 拾遗 0x00 如何在spring xml配置中使用自己的schema]]></title>
    <url>%2F2017%2F11%2F29%2Fspring0%2F</url>
    <content type="text"><![CDATA[如果我想在spring中使用下面一段自定义配置来实例化一个池1&lt;donar:pool poolSize="50" name="mypool" id="mypool"/&gt; 那么需要如下几步 #Step 1 定义 xsd 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:beans="http://www.springframework.org/schema/beans" xmlns:tool="http://www.springframework.org/schema/tool" xmlns="http://code.raycloud.com/schema/donar" targetNamespace="http://code.raycloud.com/schema/donar"&gt; &lt;!--这里是命名空间--&gt; &lt;xsd:import namespace="http://www.springframework.org/schema/beans" /&gt; &lt;xsd:import namespace="http://www.springframework.org/schema/tool" /&gt; &lt;xsd:element name="pool"&gt; &lt;xsd:complexType&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base="beans:identifiedType"&gt; &lt;xsd:attribute name="name" type="xsd:string"&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;名称&lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;/xsd:attribute&gt; &lt;xsd:attribute name="poolSize" type="xsd:int"&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;池大小&lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;/xsd:attribute&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt; &lt;/xsd:complexType&gt; &lt;/xsd:element&gt;&lt;/xsd:schema&gt; #Step 2 解析xml配置 定义命名空间处理类 1234567891011121314package com.donar.spring;import org.springframework.beans.factory.xml.NamespaceHandlerSupport;/** * Created by donar on 17/11/27. * 命名空间处理类 继承NamespaceHandlerSupport 在init方法中注册 pool 元素的解析类 */public class DonarNameSpaceHandler extends NamespaceHandlerSupport&#123; @Override public void init() &#123; registerBeanDefinitionParser("pool",new PoolBeanDefinitionParser()); &#125;&#125; 解析类 12345678910111213141516171819202122232425package com.donar.spring.bean;/** * Created by donar on 17/11/27. */public class Pool &#123; Integer poolSize; String name; public Integer getPoolSize() &#123; return poolSize; &#125; public void setPoolSize(Integer poolSize) &#123; this.poolSize = poolSize; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 123456789101112131415161718192021222324package com.donar.spring;import com.donar.spring.bean.Pool;import org.springframework.beans.factory.support.BeanDefinitionBuilder;import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;import org.w3c.dom.Element;/** * Created by donar on 17/11/27. */public class PoolBeanDefinitionParser extends AbstractSingleBeanDefinitionParser&#123; @Override protected Class&lt;?&gt; getBeanClass(Element element) &#123; return Pool.class; &#125; @Override protected void doParse(Element element, BeanDefinitionBuilder builder) &#123; String name = element.getAttribute("name"); Integer size = Integer.valueOf(element.getAttribute("poolSize")); builder.addPropertyValue("name",name); builder.addPropertyValue("poolSize",size); &#125;&#125; #Step 3 添加spring资源文件 spring.handler 用来配置解析命名空间时对应的处理类 http\://code.raycloud.com/schema/donar=com.donar.spring.DonarNameSpaceHandler spring.schemas http\://code.raycloud.com/schema/donar/donar.xsd=META-INF/donar.xsd 完成这几步后我们在spring中配置中引用我们的xsd文件 就可以在spring加载bean的时候把我们自己命名空间的标签也纳入其中了 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:donar="http://code.raycloud.com/schema/donar" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://code.raycloud.com/schema/donar http://code.raycloud.com/schema/donar/donar.xsd"&gt; &lt;donar:pool poolSize="50" name="mypool" id="mypool"/&gt; &lt;/beans&gt; 123456789101112131415import com.donar.spring.bean.Pool;import org.junit.Test;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Created by donar on 17/11/27. */public class TestSpringSchema &#123; @Test public void test()&#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationContext.xml"); Pool pool = (Pool) context.getBean("mypool"); System.out.println(pool.getName() + "---" + pool.getPoolSize()); &#125;&#125; 输出结果 1mypool---50]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>schema</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat运行时类载入或查找顺序]]></title>
    <url>%2F2017%2F09%2F13%2Ftomcatclassload%2F</url>
    <content type="text"><![CDATA[Tomcat自定义载入器（一般为WebappClassLoader）本地缓存及ClassLoader缓存 Bootstrap class loader载入（在其安全目录内） Extension class loader载入（在其安全目录内，比如这里为：$JAVA_HOME/jre/lib/ext/*.jar ） System class loader （在其安全目录内，比如这里为：CLASSPATH/）注意：以上要优先主要是基于安全，避免类似自定义java.lang.Object优先于JDK的java.lang.Object被加载 /WEB-INF/classes/*.class /WEB-INF/lib/*.jar 这里面按包名的字典顺序去加载 $CATALINA_HOME/common/classes $CATALINA_HOME/common/endorsed/*.jar $CATALINA_HOME/common/i18n/*.jar $CATALINA_HOME/common/lib/*.jar $CATALINA_BASE/shared/classes $CATALINA_BASE/shared/lib/*.jar 由于类加载器对于同名(包括包路径)的类只会加载一次所以我们可以采取些手段去改变一个类的行为 比如我们想做这么一件事 在ibatis 启动的时候我们需要检查一下sqlmap 中是不是存在注入的风险 首先我们可以重写com.ibatis.sqlmap.engine.impl.SqlMapExecutorDelegate 的 addMappedStatement方法 用正则去匹配可能存在注入风险的sql如果存在则抛异常。当然这只是最原始最野蛮的一个办法 其次我们可以将这个类单独放在一个jar包里 为了达到优先加载的目的 我们可以将jar包的名字以 _ 开头 这样就可先于 ibatis jar包里面原来的类加载 同样是这样的jar我们可以放到更前一步 比如$JAVA_HOME/jre/lib/ext 目录下 甚至我们可以使用java agent 通过jdk 的 Instrumentation 配合asm完成，当然这个就要求开发人员对 class 文件结构有一定的了解]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>类加载</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AB测试+发布系统 0-1 实现过程]]></title>
    <url>%2F2017%2F08%2F11%2Fmini-publish%2F</url>
    <content type="text"><![CDATA[支持前端项目多分支部署 支持后端项目多分支部署 支持前后端项目自由组合版本 基于IP的免配置版本切换 背景1.测试人员不太懂技术，测试时nginx配置容易出错。2.开发人员在同个项目开发不同分支，每个人开发进度不一致，测试时每次只能测一个小功能点。3.每次测完之后的版本需要保留，出了问题能够定位到是哪个版本开始出现的。4.开发人员需要一个工具，能够自动化部署测试应用。 流程首先由开发人员配置前后端项目信息，在完成发布后，配置对应的版本信息（包括nginx路由配置及版本号），版本配置完成后，由测试人员切换到响应版本进行测试。 搭建环境要求linux+mysql+redis+openresty+tomcat+maven 前端部署 配置前端信息 图中可以看到一些必要的配置信息：项目名称 git地址 git分支通过shell脚本从git上拉取前端代码并生成一个新的目录（项目名称）放置前端的代码（webpack打包压缩等在本地执行） 新建前端项目 1234mkdir $&#123;项目名称&#125; &amp;&amp;cd $&#123;项目名称&#125; &amp;&amp;git clone $&#123;git地址&#125; &amp;&amp;cd `ls $&#123;项目名称&#125;` &amp;&amp; git checkout $&#123;git分支&#125; 更新前端代码 1cd /data/front/$&#123;项目名称&#125;/`ls /data/front/$&#123;项目名称&#125;` &amp;&amp; git pull 后端部署 定制tomcat模板下载tomcat解压后修改tomcat的server.xml配置在几个端口配置的位置预留用于替换占位符 tomcat启动参数也可以在catalina.sh中按自己需求去定制下 然后像配置前端项目一样，我们先填写一些必要的信息 tomcat端口信息以及一些其他的自定义信息。 然后就开始部署一个后端项目 建立项目目录 -&gt; 拷贝tomcat模板到该目录下 -&gt; git上拉代码到代码目录 -&gt; 使用maven编译生成war包 -&gt; 将war解压到当前项目下tomcat的webapp目录 -&gt; 运行tomcat启动脚本 下面是本人写的一段丑陋的脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135项目管理脚本#!/bin/bash#项目名称PROJECT_NAME="@projectName@"PROJECT_GIT_URL="@gitPath@"GITBRANCH="@branch@"PROPERTY="@profile@"TOMCAT_PORT="@tomcatPort@"DUBBO_PORT="@dubboPort@"MODULE_NAME="@moduleName@"FINAL_NAME="@finalName@"#项目根目录HOME_ROOT="/data/project/"$PROJECT_NAME#项目源码SOURCE_DIR=$HOME_ROOT"/source/"#项目源码构建目录PROJECT_DIR=$SOURCE_DIR`ls $SOURCE_DIR`#tomcat webrootWEB_ROOT=$HOME_ROOT"/code/"#tomcat 目录TOMCAT_HOME=$HOME_ROOT"/tomcat/"MAVEN_HOME="/data/apache-maven-3.3.9"update_code()&#123; if [ -d $PROJECT_DIR ] then cd $PROJECT_DIR git checkout $GITBRANCH git pull else cd $SOURCE_DIR git clone $PROJECT_GIT_URL cd $PROJECT_DIR git checkout $GITBRANCH fi&#125;install()&#123; cd $PROJECT_DIR; $MAVEN_HOME/bin/mvn clean; $MAVEN_HOME/bin/mvn -T 1C -Dmaven.test.skip=true -Dmaven.compile.fork=true -P $PROPERTY install;&#125; deploy()&#123; TEMP=$WEB_ROOT"*" rm -fR $TEMP TEMP=$PROJECT_DIR"/"$MODULE_NAME"/target/"$FINAL_NAME"/*" cp -fR $TEMP $WEB_ROOT&#125; restart()&#123; TOMCAT_PID=`jps -v|grep $DUBBO_PORT|awk '&#123;print $1&#125;' ` kill -9 $TOMCAT_PID sleep 5 bash $TOMCAT_HOME"bin/catalina.sh" start&#125;stop()&#123; TOMCAT_PID=`jps -v|grep $DUBBO_PORT|awk '&#123;print $1&#125;' ` kill -9 $TOMCAT_PID sleep 5&#125; help()&#123; echo $"Usage: $0 &#123;update_code|install|backup|deploy|restart&#125;"&#125; case "$1" instop) stop;;update_code) update_code;;install) install;;deploy) deploy;;restart) restart;;-h) help;;--help) help;;*) update_code install deploy restart;; esac exit 0项目初始化脚本#!/bin/bashecho "project name $1"echo "tomcat port $2"echo "dubbo port $3"echo "git path $4" echo "git branch $5" echo "git profile $6" echo "moduleName $7" echo "finalName $8" #检查项目是否创建if [ ! -d "/data/project/$1" ]; then mkdir /data/project/$1; mkdir /data/project/$1/code ; mkdir /data/project/$1/source ; cp -R /data/project/tomcat /data/project/$1/; cp /data/project/publish.sh /data/project/$1/publish.sh; sed -ig "s/@projectName@/$1/" /data/project/$1/publish.sh; sed -ig "s/@tomcatPort@/$2/" /data/project/$1/publish.sh; sed -ig "s/@dubboPort@/$3/" /data/project/$1/publish.sh; sed -ig "s?@gitPath@?$4?" /data/project/$1/publish.sh; sed -ig "s/@branch@/$5/" /data/project/$1/publish.sh; sed -ig "s/@profile@/$6/" /data/project/$1/publish.sh; sed -ig "s/@moduleName@/$7/" /data/project/$1/publish.sh; sed -ig "s/@finalName@/$8/" /data/project/$1/publish.sh; cd /data/project/$1/source &amp;&amp; git clone $4 &amp;&amp; cd /data/project/$1/source/`ls /data/project/$1/source` &amp;&amp; git checkout origin/$5 sed -ig "s/@dubboPort@/$3/" /data/project/$1/tomcat/bin/catalina.sh sed -ig "s/@tomcatPort@/$2/" /data/project/$1/tomcat/conf/server.xml sed -ig "s/@ajpPort@/$(($2-1))/" /data/project/$1/tomcat/conf/server.xml sed -ig "s/@shutdownPort@/$(($2-2))/" /data/project/$1/tomcat/conf/server.xmlfi 基于上述脚本可以完成后端项目的创建更新及重新编译启动 前后端组合版本基于nginx配置在后台配置好nginx路由规则后 生成nginx配置文件 替换原有的配置后reload nginx即可 免配置版本切换将host绑定到nginx所在的机器后执行版本切换操作点击切换版本后将操作人的IP及切换的版本号写入redis中，openresty中配置如下脚本将请求路由到该版本对应的前后端项目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748在openresty配置文件的http模块中配置 init_by_lua_file /root/init.lua;init.lua#获取请求的IP对应的版本信息function getVersion() local redis = require "resty.redis" local red = redis:new() red:set_timeout(1000) -- 1 sec local ok, err = red:connect("127.0.0.1", 6379) if not ok then ngx.say("failed to connect: ", err) return end local headers=ngx.req.get_headers() local ip=headers["X-REAL-IP"] or headers["X_FORWARDED_FOR"] or ngx.var.remote_addr or "0.0.0.0" local version = red:get(ip) red:close() return versionendserver模块处配置 将请求转发到各个版本对应的前后端location / &#123; content_by_lua ' local version = getVersion() ngx.exec("@" .. version) ';&#125;location @4.8.3&#123; proxy_pass http://127.0.0.1:port;#通过这个port再转发到对应的前后端 proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 90; proxy_send_timeout 120; proxy_read_timeout 120; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; add_header Pragma "no-cache"; add_header Cache-Control "no-store, no-cache, must-revalidate, post-check=0, pre-check=0"; &#125; 这里主要就是一个 openresty+lua 的玩法 最后通过web界面将这些流程串起来就是一个兼发布及AB测试于一体的系统了 最后本文主要提供一个实现思路，抛个转。基于此思路继续延展可以做的事还很多，比如通过一些运维技术如ansible可以实现远程部署，基于openresty接入自己的业务系统又可以完成灰度任务。如果讲的有什么不会的地方欢迎大家指正。有什么问题也可以加我QQ一起讨论。]]></content>
      <categories>
        <category>应用</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
</search>
